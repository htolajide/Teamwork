import jwt from 'jsonwebtoken';
import debug from 'debug';
import bcrypt from 'bcrypt';
import pool from '../database/dbconnect';
let cloudinary = require('cloudinary').v2;

// configure cloudinary
cloudinary.config({
  cloud_name: 'ds5hogj9b',
  api_key: '657785678132187',
  api_secret: 'EcvkztYhPW8egTvRTo10OdiJpwU'
});


export default {
  signup: async (req, res) => {
    // check if user is admin
    const {
      name, bus_name, email,  password, phone, address, bus_desc, photo
    } = req.body;
    try {

      // Upload image to cloudinary
      await cloudinary.uploader.upload(photo, { tags: 'basic_sample', "width": 200, "height": 150,  })
      .then(function (image) {
      console.log();
      console.log("** File Upload (Promise)");
      console.log("* public_id for the uploaded image is generated by Cloudinary's service.");
      console.log("* " + image.public_id);
      console.log("* " + image.url);
      pool.query('SELECT email FROM trader WHERE email = $1 OR phone = $1', [email],  async (error, results) => {
          // user does not exist
          if (results.rows[0] === undefined) {
               await pool.query('INSERT INTO trader ( name, bus_name, email, phone, password, address, bus_description, photourl)'+
              ' VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, isAdmin', [ name, bus_name, email,  phone, await bcrypt.hash(password, 10), address, bus_desc, image.url],  (err, result) => {
              // signin jwt and wrap in a cookie
              const token = jwt.sign({ userId: result.rows[0].id }, process.env.SECRET);
              res.cookie('userid', result.rows[0].id, { expires: new Date(Date.now() + 3600000), httpOnly: true });
              res.cookie('token', token, { expires: new Date(Date.now() + 3600000), httpOnly: true });
              return res.status(201).json({
                message: 'Trader account successfully created',
                user_id: result.rows[0].id,
                token: token,
                is_admin: result.rows[0].isadmin,
              });
            });
          }
          return res.status(401).json({
            status: 'Error',
            error: 'Trader already exists!'
        }); 
      });
      // disconnect client
      pool.on('remove', () => {
      debug('app:*')('Client Removed @ signup');
    });
  })
    .catch(function (err) {
        console.log();
        console.log("** File Upload (Promise)");
        if (err) { debug('app:*')('Error Occured: Something wrong @uploadPhoto' + err); }
      });
    }catch (error) { debug('app:*')('Error Occured: Something wrong @uploadPhoto'); }   
  },
  // user login logic
  login: (req, res) => {
    const { email, password } = req.body;
      pool.query('SELECT id, email, password FROM trader WHERE email = $1 OR phone = $1 ', [email], async (error, results) => {
      if (error) {
        return res.status(401).json({
          status: 'error',
          error: new Error('User not found!')
        });
      }
      if (results.rows[0] === undefined) return res.jsend.error('Login failed, check your inputs');
      const match = await bcrypt.compare(password, results.rows[0].password);
      if (!match) {
        return res.jsend.error({ message: 'Login failed, check your password' });
      }
      // sign jwt and wrap in a cookie
      const token = jwt.sign({ userId: results.rows[0].id }, process.env.SECRET);
      res.cookie('userid', results.rows[0].id, { expires: new Date(Date.now() + 3600000), httpOnly: true });
      res.cookie('token', token, { expires: new Date(Date.now() + 3600000), httpOnly: true });
      return res.status(200).json({
        token: token, 
        user_id: results.rows[0].id
      });
    });
    // disconnect client after operation
    pool.on('remove', () => { 
      debug('app:login')('client removed @signin');
    });
  },
  // get all traders
  getAll: async (req, res) => {
    try {
      pool.query('SELECT id, name, bus_name, bus_description, phone, address, email, photourl, regdate FROM trader ', (error, result) => {
          if(!error){
            return res.jsend.success({
                Traders: result.rows,
            });
          }
        return res.jsend.error(error);  
      });
    } catch (error) { debug('app:*')('Error Occured: Something wrong getting all Traders'); }
    // disconnect client
    pool.on('remove', () => {
      debug('app:*')('Client Removed @gettingAllTraders');
    });
  },
  // get traders count
  getCount: async (req, res) => {
    try {
      pool.query('SELECT count(id) as number_of_trader FROM trader ', (error, result) => {
          if(!error){
            return res.jsend.success({
                NumberOfTraders: result.rows[0].number_of_trader,
            });
          }
        return res.jsend.error(error);  
      });
    } catch (error) { debug('app:*')('Error Occured: Something wrong getting traderCount'); }
    // disconnect client
    pool.on('remove', () => {
      debug('app:*')('Client Removed @gettingTraderCount');
    });
  },

  // edit article logic
  editTrader: async (req, res) => {
    const { token, userid } = req.cookies;
    const { name, bus_name, email, bus_desc, phone, address } = req.body;
    // token = req.header();
    try {
        pool.query('UPDATE  trader SET  name = $1, bus_name = $2, bus_description = $3, phone = $4, address = $5, email = $6  WHERE id = $7 RETURNING name, phone, regdate', [name, bus_name, bus_desc, phone, address, email, userid], (err, result) => {
          if(result === undefined){ return res.jsend.error("Trader update failed "+ err);}
          if (!err) {
            return res.jsend.success({
              message: 'info succesfully updated',
              name: result.rows[0].name,
              phone: result.rows[0].phone,
              reg_date: result.rows[0].reg_date,
            });
          } 
          return res.jsend.error(err);
        });
    } catch (error) { debug('app:*')('Error Occured: Something wrong @editTrader'); }
    // disconnect client
    pool.on('remove', () => {
      debug('app:*')('Client Removed @ editTrader');
    });
  },
  // edit article logic
  changePassword: async (req, res) => {
    const { password, email } = req.body;
    // token = req.header();
    try {
        pool.query('UPDATE  trader SET password = $1  WHERE email = $2 OR phone= $2 RETURNING name, phone, regdate ', [await bcrypt.hash(password, 10), email], (err, result) => {
          if(result.rows[0] === undefined){ return res.jsend.error("Trader is not registered");}
          if (!err) {
            return res.jsend.success({
              message: 'Password successfully Changed',
              name: result.rows[0].name,
              phone: result.rows[0].phone,
              regdate: result.rows[0].regdate,
            });
          } 
          return res.jsend.error(err);
        });
    } catch (error) { debug('app:*')('Error Occured: Something wrong @editTrader'); }
    // disconnect client
    pool.on('remove', () => {
      debug('app:*')('Client Removed @ editTrader');
    });
  },
};
